\section{Problemanalyse}   %wo liegen die Probleme oder Schwierigkeiten in einer Ligrettosimulation mit verteilten Systemen?

%allgemein, was muss analysiert werden

Als Aufgabe gilt es, den Ablauf, der durch die Spielregeln festgelegt ist, anhand folgender Gesichtspunkte in einen Algorithmus umzusetzen:


\begin{enumerate}
	\item Der Spielablauf muss den Spielregeln entsprechen und die KI-Algorithme, welche die Mitspieler simulieren, sollten nur an Informationen über den Spielablauf gelangen, welche auch ein menschlicher Spieler gelangen würde.
	\item Der Spielablauf sollte möglichst fair sein. D.h. bis auf den Zufall, der durch das Mischen der Karten ins Spiel gelangt, sollten alle Mitspieler gleichgestellt sein.
	\item Die verwendeten Algorithmen und Schnittstellen sollten möglichst gut mit der Anzahl Mitspieler skalieren, unter Betrachtung der benötignen Rechenzeit und Netzerkkapazität.
\end{enumerate}

Folgende Punkte werden bei der Herleitung des Algorithmus nicht betrachtet:

\begin{enumerate}
	\item Alle Mitspieler müssen sich an die Spielregeln halten, insbesonder in Teilen des Ablaufs, die im Spiel mit menschlichen Spielern nicht überwacht werden können. Dazu gehör z.B. das regelkonforme Ablegen der Handkarten beim suchen einer passenden Karte.
	\item Die beiligten Server versenden nur Nachrichten an Server, mit denen sie laut dem Alogrithmus kommunizieren dürfen.
	\item Die eingesetzte Software und Hardware darf keine Fehler aufweisen und der Netzerkverkehr darf nicht gestört oder unterbrochen werden. D.h. z.B. keine Pakete dürfen verloren gehen.
\end{enumerate}

%Für die letzten beiden Punkte wird anschliessend eine Diskusion gegeben, inwiefern der Alogorithmus und die Schnittstellen angepasst werden müssten, um ...

\subsection{Systemgrenzen}

%welche teile des algorithmus laufen wo

Damit die Laufzeit eines Spiels nicht, oder nur schwach, mit der Anzahl Spieler wächst, muss die Anzahl verwendeter Server linear mit der Anzahl Mitspieler wachsen können. Deshalb ist es notwendig und sinnvoll für jeden Mitspieler mindestens einen, separaten Prozess zu Verwenden.

Da ein einzelner Spieler jedoch zu jeder Zeit immer nur eine Aktion ausführen darf (siehe Spielregeln), ist eine Aufteilung eines einzelenen Spielers in mehrere Prozesse nicht sinnvoll.

Zur Überwachung des gesammten Spiels, sowie dessen Aufbau und Abbau, wird ein separater Prozess verwendet. Da der Überwachende Prozess nur vor Spielbeginn und nach Beendigung des Spiels eine Aufgabe hat, dessen Komplexität mit der Anzahl mitspieler wächst, ist eine Aufteilung deiser Aufgaben in mehrere Prozesse zwar erwägenswert, aber nicht von oberster Priorität.

% TODO: Nomenklatur für den Überwachende Prozess und Mitspieler-Prozesse

Zusammengefasst:

\begin{enumerate}
	\item Ein Prozess zur Überwachung des Spiels (Aufbau und Abbau).
	\item Ein Prozess pro Mitspieler, welche alle Aktionen des jeweiligen Mitspielers durchführt.
\end{enumerate}

\subsection{Verteilung}

%welcher state ist wo

Bei der Betrachtung der Verteilung des Zustandes gibt es drei Arten von Objekten:

\begin{enumerate}
	\item {\bf Zustands-Objekte} verkörpern den veränderlichen Zustand eines Spiels. Die Eigenschaften dieser Objekte sind somit mutierbar. Für diese Objekte ist immer genau ein Prozess zuständig und diese Objekte werden auf andere Prozesse verschoben oder kopiert.
	\item {\bf Token-Objekte} werden zur Kommunikation verwendet und sind nicht weränderbar. Token-Objekte können zwischen den Prozessen verschoben werden, jedoch ist immer nur genau ein Prozess für ein jeweiliges Token-Objekt verantwortlich.
	\item {\bf Transiente Objekte} werden zu Kommunikations-Zwecken und zur unterstützung der Algorithmen erstellt und aufbewahrt. Wenn ein transientes Objekt an einen anderen Prozess versendet wird, dann besitzen beide Prozess eine eigene Kopie des Objektes.
\end{enumerate}

Die folgenden Token-Objekte können identifiziert werden:
\begin{enumerate}
	\item Spielkaren: Zu beginn des Spieles wird für jede Spielkarte, welche in einen realen Ligretto-Spiel verwerdet würde, ein Spielkarten-Objekt erstellt.
\end{enumerate}

Folgende Zustands-Obekte können identifiziert werden:
\begin{enumerate}
	\item Handkarten-Stapel
	\item Ausgelegte Karten vor dem Mitspieler
	\item Stapel auf dem Spieltisch
	\item Mitspieler
	\item Überwachender Prozess
\end{enumerate}

Zur Kommunikation werden folgende Transiente Objekte erstellt:
\begin{enumerate}
	\item Start- und Stop-Signale des überwachenden Prozesses.
	\item Stop-Signal eines Mitspielers.
	\item Stapel mit gemischten Karten, welche vom Überwachenden Prozess and die Mitspieler verteilt werden.
	\item ...
\end{enumerate}

\subsection{Kommunikation}

Bei der definition der Kommunikation muss gleichzeitig die Korrektheit und die Performance beachtet werden.

Der Ablauf lässt sich in folgende Abschnitte unterteilen:
\begin{enumerate}
	\item Während dem {\bf Aufbau} werden die Spielkarten durch den Server vorbereitet und and die regisrierten Clients verteilt.
	\item Stop-Signal eines Mitspielers.
	\item Stapel mit gemischten Karten, welche vom Überwachenden Prozess and die Mitspieler verteilt werden.
	\item ...
\end{enumerate}


%für was wird wie kommuniziert

\subsubsection{Vor Spielbeginn}

Ausgangslage bei Spielbeginn ist folgende:
\begin{itemize}
\item Der Server kennt alle Spieler, die an dieser Spielrunde teilnehmen.
\item Dem Server stehen eine entsprechende Anzahl gut gemischter Kartendecks zur Verfügung.
\item Kommunikationsgrundlagen (Netzwerk, RMIRegistry, etc...) sind gegeben.
\end{itemize}

\subsubsection{Spielinitialisierung}
Zuerst initialisiert der Server alle ihm bekannten Spieler, indem er über RMI deren init-Methode aufruft. Dabei werden sämtliche Informationen, die ein Spieler kenne muss, übermittelt. (Referenz zum Server und zu den Mitspielern, die gemischten Karten)

\subsubsection{Spielstart}
Nach der Initialisierung werden alle Spieler über den Spielstart informiert. Dies geschieht über den Remoteaufruf der Methode spielStart.

\subsubsection{Während des Spiels}
Sobald ein Spieler über den Spielstart informiert wurde, versucht er der Reihe nach die Karten aus seinen Spielslots oder jene aus seinem Handstapel auf einen eigenen oder den Stapel eines Nachbarn zu legen. Für einen Versuch auf dem eigenen Stapel ist kein Remoteaufruf nötig. Um die Karte bei einem Nachbarn zu platzieren, wird diesem die Karte mittels Aufruf der Methode legeKarte übergeben. Hat die Karte auf einem Stapel platzgefunden, so bestätigt das der Empfänger der Karte mit true, ansonsten gibt er false zurück und die Karte geht wieder zurück in den Slot bzw. in den Handkartenstapel.

\subsubsection{Ligretto Stop!}
Ist der Ligrettostapel eines Spielers leer, so ruft er die ligrettoStop-Methode des Servers auf. Dieser übermittelt diese Botschaft allen Spielern, indem er deren spielEnde-Methode aufruft.

\subsubsection{Punkte zählen}
Nach Spielende, ruft der Server von allen Spielern den Punktestand ab. Dies geschieht über dem RMI-Aufruf der Methode getPunkte.


\subsection{Concurrency-Problem}

\subsubsection{Gleichzeitiges Legen einer Karte}
Es kommt vor, dass zwei Spieler gleichzeitig versuchen die selbe Karte auf den selben Stapel zu legen. Wie im echten Spiel gilt auch in der Spielsimlulation: "First come first served". Dabei werden alle RMI-Methoden mit dem \textbf{synchronized}-Schlüsselwort synchronisiert.

\subsubsection{Spielstop währenddem eine Karte gelegt wird}
Wird das Spiel während einem Versuch, eine Karte auf den Stapel zu legen beendet, darf die Karte gemäss Spielregeln nicht mehr gelegt werden. Dies kann erreicht werden, indem man die Erfolgsmeldung mit dem Spielstatus verknüpft. Ist das Spiel beim Aufruf der legeKarte-Methode beendet, wird in jedem Fall false zurückgegeben.

\subsection{Zuverlässigkeit}

\subsubsection{Verlorenes Netzwerkpaket}
Da wir uns für den Einsatz von RMI entschieden haben, brauchen wir uns um Paketverlust etc. keine Gedanken zu machen. RMI benutzt TCP zur Kommunikation und stellt somit die Übermittlung einer Nachricht sicher.

\subsubsection{Absturz eines Spielers}
Stürzt ein Spieler während des Spiels ab, so beeinträchtigt das den Verlauf des Spiels nicht. Um eine lange Antwortzeit beim Legen einer Karte zu vermeiden werden ihn seine Nachbarn für weitere Anfrageversuche ignorieren.

\subsubsection{Absturz des Servers}
Da der Server für die Übermittlung der Ligretto-Stop-Nachricht verantwortlich ist, hätte ein Serverabsturz zur Folge dass alle Spieler Spielen, bis sie ihren Ligrettostapel abgearbeitet haben, und dann beim Aufruf der ligrettoStop-Methode erfahren, dass der Server keine Antwort mehr gibt. Der Spielausgang wäre damit verfälscht und nicht brauchbar.

\subsection{Skallierbarkeit}

Gemäss Spielregeln braucht es mindestens zwei Spieler für ein Ligrettospiel. Gegen oben existieren keine Grenzen. Dadurch dass nur eine Kommunikation mit einer konstanten Anzahl Nachbarn erfolgt, bleibt die Netzwerkauslastung und der Rechenaufwand pro Spieler auch bei steigender Anzahl Gegner konstant. Je nach Implementation können Nachrichten, welche an alle Spieler gehen (spielStart und spielEnde) durch Grenzen der Netzwerkgeschwindigkeit etwas verspätet eintreffen.

%Bewertungsmassstab:
% Bei Ligretto berücksichtigen, dass die Anzahl Spieler steigen kann.
%    - Ist die Zahl der beteiligten Rechner definiert? Wieviele Rechner sind minimal nötig, wieviele können max. eingesetzt werden?
%    - Wie steigt die Leistung des Systems mit hinzugefügten Rechnern? (Bis zu 1 Zusatzpunkt für detaillierte Analyse)
